-- Supabase Schema for 牛乳配達顧客管理システム
-- 注意:
-- - タイムスタンプはすべて UTC (timezone('utc', now())) を既定とします。
-- - ID は BigInt の IDENTITY（オートインクリメント）を採用します。
-- - CHECK 句で既存実装の制約を再現しています。

-- 1. マスター系テーブル ------------------------------------------------------

create table if not exists delivery_courses (
  id bigint generated by default as identity primary key,
  custom_id text unique,
  course_name text not null,
  description text,
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now())
);

create index if not exists idx_delivery_courses_custom_id on delivery_courses (custom_id);

create table if not exists delivery_staff (
  id bigint generated by default as identity primary key,
  staff_name text not null,
  phone text,
  email text,
  notes text,
  course_id bigint references delivery_courses(id) on delete set null,
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now())
);

create table if not exists manufacturers (
  id bigint generated by default as identity primary key,
  manufacturer_name text not null,
  contact_info text,
  notes text,
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now())
);

create table if not exists products (
  id bigint generated by default as identity primary key,
  custom_id text unique,
  product_name text not null,
  manufacturer_id bigint references manufacturers(id) on delete set null,
  unit_price numeric(10,2) not null,
  unit text,
  description text,
  tax_category text,
  created_at timestamptz not null default timezone('utc', now())
);

create index if not exists idx_products_custom_id on products(custom_id);
create index if not exists idx_products_manufacturer on products(manufacturer_id);

-- スタッフとコースの多対多
create table if not exists staff_courses (
  id bigint generated by default as identity primary key,
  staff_id bigint not null references delivery_staff(id) on delete cascade,
  course_id bigint not null references delivery_courses(id) on delete cascade,
  created_at timestamptz not null default timezone('utc', now()),
  unique (staff_id, course_id)
);

-- 会社情報（単一行想定）
create table if not exists company_info (
  id bigint primary key default 1,
  company_name text not null,
  company_name_kana_half text,
  postal_code text,
  address text,
  phone text,
  fax text,
  email text,
  representative text,
  business_hours text,
  established_date date,
  capital text,
  business_description text,
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now())
);

-- 収納機関情報（単一行想定）
create table if not exists institution_info (
  id bigint primary key default 1,
  institution_name text,
  bank_code_7 text,
  bank_name text,
  branch_name text,
  agent_name_half text,
  agent_code text,
  header_leading_digit text,
  notes text,
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now())
);

-- 認証ユーザープロファイル（ロール管理）
create table if not exists profiles (
  user_id uuid primary key references auth.users(id) on delete cascade,
  role text not null default 'viewer',
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now())
);

create index if not exists idx_profiles_role on profiles(role);

create or replace function trg_profiles_updated_at()
returns trigger
language plpgsql
as $$
begin
  new.updated_at := timezone('utc', now());
  return new;
end;
$$;

do $$
begin
  if not exists (
    select 1 from pg_trigger where tgname = 'trg_profiles_updated_at_on_update'
  ) then
    create trigger trg_profiles_updated_at_on_update
    before update on profiles
    for each row
    execute function trg_profiles_updated_at();
  end if;
end;
$$;

-- 2. 顧客・配達関連テーブル ---------------------------------------------------

create table if not exists customers (
  id bigint generated by default as identity primary key,
  custom_id text unique,
  customer_name text not null,
  yomi text,
  address text,
  phone text,
  email text,
  course_id bigint references delivery_courses(id) on delete set null,
  staff_id bigint references delivery_staff(id) on delete set null,
  contract_start_date date,
  notes text,
  delivery_order integer not null default 0,
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now())
);

create index if not exists idx_customers_course on customers(course_id, delivery_order);
create index if not exists idx_customers_custom_id on customers(custom_id);

create table if not exists delivery_patterns (
  id bigint generated by default as identity primary key,
  customer_id bigint not null references customers(id) on delete cascade,
  product_id bigint not null references products(id) on delete restrict,
  delivery_days jsonb, -- 週間配達曜日（例: [1,3,5]）
  quantity integer default 1, -- 後方互換用（固定本数）
  daily_quantities jsonb, -- 曜日ごとの本数 { "1": 2, "3": 1 }
  unit_price numeric(10,2) not null,
  start_date date,
  end_date date,
  is_active boolean not null default true,
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now())
);

create index if not exists idx_delivery_patterns_customer on delivery_patterns(customer_id, is_active);
create index if not exists idx_delivery_patterns_product on delivery_patterns(product_id);

do $$
begin
  if not exists (select 1 from pg_type where typname = 'temporary_change_type') then
    create type temporary_change_type as enum ('skip', 'add', 'modify');
  end if;
end
$$;

create table if not exists temporary_changes (
  id bigint generated by default as identity primary key,
  customer_id bigint not null references customers(id) on delete cascade,
  change_date date not null,
  change_type temporary_change_type not null,
  product_id bigint references products(id) on delete set null,
  quantity integer,
  unit_price numeric(10,2),
  reason text,
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now())
);

create index if not exists idx_temporary_changes_customer_date on temporary_changes(customer_id, change_date);

-- 操作ログ（バッチ処理などで使用）
create table if not exists operation_logs (
  id bigint generated by default as identity primary key,
  op_type text not null,
  description text,
  params_json jsonb,
  data_json jsonb,
  created_at timestamptz not null default timezone('utc', now())
);

create index if not exists idx_operation_logs_type_created_at on operation_logs(op_type, created_at desc);

-- 顧客ごとの請求設定
do $$
begin
  if not exists (select 1 from pg_type where typname = 'billing_method') then
    create type billing_method as enum ('collection', 'debit');
  end if;
end
$$;

create table if not exists customer_settings (
  customer_id bigint primary key references customers(id) on delete cascade,
  billing_method billing_method,
  rounding_enabled boolean not null default true,
  bank_code text,
  branch_code text,
  account_type integer check (account_type in (1,2)),
  account_number text,
  account_holder_katakana text,
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now())
);

-- 3. 請求・入金管理 -----------------------------------------------------------

create table if not exists ar_invoices (
  id bigint generated by default as identity primary key,
  customer_id bigint not null references customers(id) on delete cascade,
  year integer not null,
  month integer not null check (month between 1 and 12),
  amount integer not null,
  rounding_enabled boolean not null default true,
  status text not null default 'confirmed' check (status in ('draft','confirmed','canceled')),
  confirmed_at timestamptz default timezone('utc', now()),
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now()),
  unique (customer_id, year, month)
);

create index if not exists idx_ar_invoices_customer_period on ar_invoices(customer_id, year, month);

create table if not exists ar_payments (
  id bigint generated by default as identity primary key,
  customer_id bigint not null references customers(id) on delete cascade,
  year integer not null,
  month integer not null check (month between 1 and 12),
  amount integer not null,
  method billing_method,
  note text,
  created_at timestamptz not null default timezone('utc', now())
);

create index if not exists idx_ar_payments_customer_period on ar_payments(customer_id, year, month, created_at desc);

create table if not exists ar_ledger (
  id bigint generated by default as identity primary key,
  customer_id bigint not null references customers(id) on delete cascade,
  year integer not null,
  month integer not null check (month between 1 and 12),
  opening_balance integer not null default 0,
  invoice_amount integer not null default 0,
  payment_amount integer not null default 0,
  carryover_amount integer not null default 0,
  created_at timestamptz not null default timezone('utc', now()),
  updated_at timestamptz not null default timezone('utc', now()),
  unique (customer_id, year, month)
);

create index if not exists idx_ar_ledger_customer_period on ar_ledger(customer_id, year, month);

-- 請求サマリー更新 RPC ---------------------------------------------------------

create or replace function rpc_update_customer_ledger(target_customer_id bigint, target_year integer, target_month integer)
returns ar_ledger
language plpgsql
as $$
declare
  previous_year integer := case when target_month = 1 then target_year - 1 else target_year end;
  previous_month integer := case when target_month = 1 then 12 else target_month - 1 end;
  prev_carryover integer := 0;
  invoice_total integer := 0;
  payment_total integer := 0;
  rounding_enabled boolean := true;
  inserted ar_ledger;
begin
  select rounding_enabled
  into rounding_enabled
  from ar_invoices
  where customer_id = target_customer_id
    and year = target_year
    and month = target_month
  order by confirmed_at desc
  limit 1;

  select carryover_amount
  into prev_carryover
  from ar_ledger
  where customer_id = target_customer_id
    and year = previous_year
    and month = previous_month;

  if prev_carryover is null then
    prev_carryover := 0;
  end if;

  select coalesce(sum(amount), 0)
  into invoice_total
  from ar_invoices
  where customer_id = target_customer_id
    and year = target_year
    and month = target_month
    and status = 'confirmed';

  select coalesce(sum(amount), 0)
  into payment_total
  from ar_payments
  where customer_id = target_customer_id
    and year = target_year
    and month = target_month;

  insert into ar_ledger (
    customer_id,
    year,
    month,
    opening_balance,
    invoice_amount,
    payment_amount,
    carryover_amount,
    updated_at
  )
  values (
    target_customer_id,
    target_year,
    target_month,
    prev_carryover,
    invoice_total,
    payment_total,
    prev_carryover + invoice_total - payment_total,
    timezone('utc', now())
  )
  on conflict (customer_id, year, month) do update
  set opening_balance = excluded.opening_balance,
      invoice_amount = excluded.invoice_amount,
      payment_amount = excluded.payment_amount,
      carryover_amount = excluded.carryover_amount,
      updated_at = excluded.updated_at
  returning * into inserted;

  return inserted;
end;
$$;

create or replace function rpc_confirm_invoice(target_customer_id bigint, target_year integer, target_month integer, target_rounding_enabled boolean)
returns ar_invoices
language plpgsql
as $$
declare
  raw_amount integer := 0;
  rounded_amount integer := 0;
  existing ar_invoices;
begin
  select coalesce(sum(amount), 0)
  into raw_amount
  from ar_invoices
  where customer_id = target_customer_id
    and year = target_year
    and month = target_month
    and status = 'confirmed';

  if target_rounding_enabled then
    rounded_amount := raw_amount - (raw_amount % 10);
  else
    rounded_amount := raw_amount;
  end if;

  insert into ar_invoices (
    customer_id,
    year,
    month,
    amount,
    rounding_enabled,
    status,
    confirmed_at
  )
  values (
    target_customer_id,
    target_year,
    target_month,
    rounded_amount,
    target_rounding_enabled,
    'confirmed',
    timezone('utc', now())
  )
  on conflict (customer_id, year, month) do update
  set amount = excluded.amount,
      rounding_enabled = excluded.rounding_enabled,
      status = 'confirmed',
      confirmed_at = timezone('utc', now())
  returning * into existing;

  perform rpc_update_customer_ledger(target_customer_id, target_year, target_month);

  return existing;
end;
$$;

create or replace function rpc_unconfirm_invoice(target_customer_id bigint, target_year integer, target_month integer)
returns ar_invoices
language plpgsql
as $$
declare
  existing ar_invoices;
begin
  update ar_invoices
  set status = 'draft',
      confirmed_at = null,
      updated_at = timezone('utc', now())
  where customer_id = target_customer_id
    and year = target_year
    and month = target_month
  returning * into existing;

  perform rpc_update_customer_ledger(target_customer_id, target_year, target_month);

  return existing;
end;
$$;

-- Undo スタック ---------------------------------------------------------------

create table if not exists undo_stack (
  id bigint generated by default as identity primary key,
  customer_id bigint not null references customers(id) on delete cascade,
  action_type text not null,
  payload jsonb not null,
  created_at timestamptz not null default timezone('utc', now()),
  metadata jsonb
);

create index if not exists idx_undo_stack_customer_created_at on undo_stack(customer_id, created_at desc);

create or replace function rpc_push_undo(
  target_customer_id bigint,
  target_action_type text,
  target_payload jsonb,
  target_metadata jsonb default null
)
returns undo_stack
language plpgsql
as $$
declare
  inserted undo_stack;
begin
  insert into undo_stack (customer_id, action_type, payload, metadata)
  values (target_customer_id, target_action_type, target_payload, target_metadata)
  returning * into inserted;

  return inserted;
end;
$$;

create or replace function rpc_pop_undo(target_customer_id bigint)
returns undo_stack
language plpgsql
as $$
declare
  latest undo_stack;
begin
  select *
  into latest
  from undo_stack
  where customer_id = target_customer_id
  order by created_at desc
  limit 1;

  if latest is null then
    return null;
  end if;

  delete from undo_stack where id = latest.id;

  return latest;
end;
$$;

create table if not exists master_undo_stack (
  id bigint generated by default as identity primary key,
  entity_type text not null,
  entity_id bigint,
  action_type text not null,
  payload jsonb not null,
  metadata jsonb,
  created_at timestamptz not null default timezone('utc', now())
);

create index if not exists idx_master_undo_stack_entity on master_undo_stack(entity_type, entity_id, created_at desc);

create or replace function rpc_push_master_undo(
  target_entity_type text,
  target_entity_id bigint,
  target_action_type text,
  target_payload jsonb,
  target_metadata jsonb default null
)
returns master_undo_stack
language plpgsql
as $$
declare
  inserted master_undo_stack;
begin
  insert into master_undo_stack (entity_type, entity_id, action_type, payload, metadata)
  values (target_entity_type, target_entity_id, target_action_type, target_payload, target_metadata)
  returning * into inserted;

  return inserted;
end;
$$;

create or replace function rpc_pop_master_undo(
  target_entity_type text,
  target_entity_id bigint default null
)
returns master_undo_stack
language plpgsql
as $$
declare
  latest master_undo_stack;
begin
  select *
  into latest
  from master_undo_stack
  where entity_type = target_entity_type
    and (target_entity_id is null or entity_id = target_entity_id or entity_id is null)
  order by created_at desc
  limit 1;

  if latest is null then
    return null;
  end if;

  delete from master_undo_stack where id = latest.id;

  return latest;
end;
$$;

-- 4. 監査用・補助テーブルが必要になった際はここに追記すること。

